;縦書きモードでは、デフォルトの選択肢処理(select文系）と、
;メニュー処理（rmenu系）がすべて無効になります。
;つまり、すべてカスタマイズしなければなりません。

;2004/4/9 縦書き時のsetwindowの仕方の解説を加えました。
;setwindow x,y,x_num,y_num,width,height,pitchx,pitchy,（あとは横書きと同じ）
;x,y=文字の表示位置左上座標
;x_num,y_num 横、縦の文字文字数
;width,height 文字フォントの大きさ
;pitchx,pitchy 横、縦の文字間の空白の大きさ
;
;実際に文字が表示されるのは右上からですから、文字の表示位置は、
;x+(x_num-1)*(width+pitchx) になります。
;そこから文字を書き始めることになりますので、文字の右端は、
;x+x_num*(width+pitchx)-1 です。
;これが画面からはみださないようにしてください。
;なお、ルビを振るときはルビが入るようにpitchxを取ってください。



*text_lb
;ここでは最低限のことしかしていませんが、
;ボタンを設定して処理を組み込むことも出来ます。
;カーソルはスプライトで実装してください。

btndef clear
*tbloop
textbtnwait %0
if %0=0 goto *text_end
if %0=-3 goto *text_end		;普通のクリックとホイール↓入力
if %0=-1 gosub *rclk:goto *text_lb	;右クリック
if %0=-2 systemcall lookback:goto *tbloop	;ホイール上入力
goto *tbloop

*text_end
texec
saveon
return






*customsel
skipoff
*csel_st
btndef clear
getcselnum %0
getcursorpos %1,%2
cselbtn 0,500,%1,%2
sub %1,21
cselbtn 1,501,%1,%2
if %0>2 sub %1,21:cselbtn 2,502,%1,%2
if %0>3 sub %1,21:cselbtn 3,503,%1,%2
if %0>4 sub %1,21:cselbtn 4,504,%1,%2

*csel_loop
selectbtnwait %0
if %0=-2 systemcall lookback:goto *csel_loop
if %0=-1 gosub *rclk:goto *csel_st
if %0>=500 & %0<=504 saveon:sub %0,500:cselgoto %0
goto *csel_loop







*rclk
;右クリック処理
systemcall windowerase
;ここでは単にウィンドウを消してますが、
;ここにボタン処理でメニューを組むことが出来ます。
;systemcall文やsavegame文などをうまく使ってください。
return









*define
rubyon 4,4
caption "縦書きサンプル"
humanz 100
windowback
textgosub *text_lb
usewheel
game

*start
bg #aa8844,10,1000
click
setwindow 30,30,20,20,20,20,0,0,10,1,1,#BB8866,20,20,440,440
tateyoko 1
goto *game_start


*game_start
縦書きサンプルです。@
これを参考にして色々組んでください。\
あああああああああ@あああああああ\
選択肢も表示されます。

csel "選択肢１",*s1,"選択肢２",*s2,"選択肢３",*s3

*s1
選択肢１を選択しました。\
end


*s2
選択肢２を選択しました。\
end

*s3
選択肢３を選択しました。\
end